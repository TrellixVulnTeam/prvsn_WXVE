#!/usr/bin/python

import argparse
import atexit
import logging
import os
import sys

parent_directory = os.path.split(os.path.dirname(__file__))[-1]
if parent_directory == 'scripts':
    sys.path.append(os.path.join(parent_directory, '..'))

from prvsnlib.models import Runbook, Package, LocalTarget, RemoteTarget
from prvsnlib.packager import Packager
from prvsnlib.utils.list import unique
from prvsnlib.utils.timer import Timer


def parser():
    parser = argparse.ArgumentParser(description='Simple machine provisioning tool.')
    parser.add_argument('-v', '--verbose',
                        action='store_true',
                        help='Verbose output')

    subparsers = parser.add_subparsers(title='subcommands', dest='command')

    parser_init = subparsers.add_parser('init', help='Initialize a new runbook.')
    parser_init.add_argument('runbook',
                             default=Runbook.DEFAULT_FILENAME,
                             nargs='?',
                             help='Path to the runbook (default: %s)' % Runbook.DEFAULT_FILENAME)

    parser_package = subparsers.add_parser('package', help='Package a runbook.')
    parser_package.add_argument('runbooks',
                                metavar='runbook',
                                nargs='*',
                                help='Path to the runbook (default: %s)' % Runbook.DEFAULT_FILENAME)
    parser_package.add_argument('-o', '--output',
                                action='store',
                                default=Package.DEFAULT_FILENAME,
                                help='Package output file (default: %s)' % Package.DEFAULT_FILENAME)

    parser_run = subparsers.add_parser('run', help='Run a runbook or apply a package.')
    parser_run.add_argument('-s', '--sudo',
                            action='store_true',
                            help='Run provisioning as root (default: login user)')
    parser_run.add_argument('--no-copy-keys',
                            action='store_true',
                            help='Do not copy public ssh keys to remote (default: copy)')
    parser_run.add_argument('runbooks_and_packages_and_remotes',
                            metavar='runbook',
                            default=Runbook.DEFAULT_FILENAME,
                            nargs='*',
                            help='Path to the runbook (default: %s)' % Runbook.DEFAULT_FILENAME)
    parser_run.add_argument('_',
                            metavar='package',
                            nargs='*',
                            help='Path to the package (default: none)')
    parser_run.add_argument('_',
                            metavar='remote',
                            nargs='*',
                            help='Host to provision (default: local)')
    return parser


def parse_extra(args):
    o = unique(args.runbooks_and_packages_and_remotes)
    runbooks = [x for x in o if Runbook(x).is_runnable]
    packages = [x for x in o if Package(x).is_applicable]
    targets = [x for x in o if x not in runbooks and x not in packages and RemoteTarget(x).is_valid]
    return \
        [Runbook(x) for x in runbooks], \
        [Package(x) for x in packages], \
        [RemoteTarget(x) for x in targets] if targets else [LocalTarget()]


def main():
    t = Timer()
    atexit.register(t.log_elapsed_time)

    args = parser().parse_args()
    runbooks, packages, targets = parse_extra(args)

    if args.verbose:
        logging.root.setLevel(logging.DEBUG)
        logging.debug('Logging verbose')
    else:
        logging.root.setLevel(logging.INFO)

    if args.command == 'init':
        logging.debug('Init')
        Runbook.create(args.runbook)

    elif args.command == 'package':
        logging.debug('Package')

        # TODO check this
        # Packager(
        #     [Runbook(runbook) for runbook in runbooks],
        #     dest=args.output,
        #     verbose=args.verbose,
        # ).build_package()

    elif args.command == 'run':
        logging.debug('Run')

        # TODO check this
        # if remotes:
        #
        #
        #     Packager(
        #         ,
        #         dest=args.output,
        #         verbose=args.verbose,
        #     ).build_package()
        #
        #     for remote in remotes:
        #         Remote(
        #             remote,
        #             package=args.output,
        #             sudo=args.sudo,
        #             no_copy_keys=args.no_copy_keys,
        #         ).run()
        #
        # else:
        #
        #
        #     if args.sudo:
        #         if os.geteuid() != 0:
        #             if sys.stdout.isatty():
        #                 os.execvp('sudo', ['sudo', '-p', 'sudo password:'] + sys.argv)
        #             else:
        #                 logging.warning('Cannot sudo because not a tty. Running as user ' + getpass.getuser() + '.')
        #
        #     Provisioner(
        #         [Runbook(runbook) for runbook in runbooks]
        #     ).run()


if __name__ == '__main__':
    main()
